#======================================
ALGO - Java Data Structures and Algorithms
#======================================

Requirements:
1. Java 1.6



This project provides solution to various java programming interview questions. There is an interactive applet (com.test.ProblemApplet ) that shows all the questions. Select one of the question in the applet to run it. In order to compile and run the project, use the following commands:

Algo>cd src
src>javac -d ../bin/ com/test/ProblemApplet.java 
src>javac -d ../bin/ com/questions/*/*.java
src>javac -d ../bin/ com/questions/tree/bst/*.java
src>javac -d ../bin/ com/questions/linkedlist/single/*.java
src>cd ..
Algo>cp -R META-INF bin/
Algo>java -cp bin com.test.ProblemApplet


Questions Remaining
1. Sort a link list using merge sort.
2. Find 3rd largest element in an array 
3. There is a linked list whose node has 3 fields, val, next pointer & random pointer...next 
pointer points to next node in the list and random pointer can point to any node in the list.
Write an efficient function which takes such list and returns the copy/clone of that list.
http://www.careercup.com/question?id=9304676
4. Find 2nd largest element in a binary search tree
5. For a given BST, create a different linked list for each level
6. Deletion of a node 
7. Morris Traversal
8. Convert BST to Circular Double Linked List
9. Find biggest number that is smaller than the given number
10. find second most biggest number
11. Find the maximum depth of the BST
12. Given a binary search tree, design an algorithm which creates  a linked list of all the nodes at each depth.
(eg. if you have a tree with depth D, you will have D linked list)
13. Given a binary Search tree and a Node, How would you transform the tree to make that Node as root.The resulting tree should be a BST.
14. Given a value and a binary search tree. Print all the paths(if there exists more than one) 
which sum up to that value. It can be any path in the tree. It doesn't have to be from the root (NP-Hard Problem) 
16. Design an algorithm to find path from one node in a binary tree to another
Source: http://courses.csail.mit.edu/iap/interview/Hacking_a_Google_Interview_Handout_3.pdf
17 Explain Different types of binary tree traversal
   * Depth-First
   ** Inorder -- Left, Node, Rith -- sorting
   ** Preorder -- Node, Left, Right -- Copy BST, Prefix expression
   ** Postorder -- Left, Right, Node -- Postfix
   * Level-Order/Breadth First



Red-Black Trees:
* Insertion Rules:
   1. Every node is either red or black 
   2. The root is always black
   3. If a node is red, its children must be black. Although the converse it not necessarily true
   4. Every path from the root to leaf or null node must have same number of black nodes. 


BST Hints:
  * Depth of Tree = Log(N)/Log(2)  = log(N, base=2)
  * Number of Leaf Nodes = 2^(Height) = 2^(log(N, base=2))
  * Inorder -- Left, Node, Right
  * PreOrder -- Node, Left, Right
  * PostOrder -- Left, Right, Node
  * Number of nodes = 2^(height+1) - 1
Representing Tree as Array
	** Left Child: 2*Index +1
	** Right Child: 2*Index + 2
	** Parent = (index-1)/2
	** 
  
  
Key Algorithms:
1. Morris Traversal for Binary Search Trees: Convert binary search tree to circular double linked list in place
2. Subset Sum Problem 
3. Sorting Algorithms: Merge sort, Quick Sort, Radix Sort, Bubble Sort, ...
4. Fi


FAQ:

* Explain fail-safe
	Fail-safe doesn't raises ConcurrentModificationException. Read more about Fail Safe/Fail Fast here: 
	http://www.jguru.com/faq/view.jsp?EID=221988

* Difference between HashMap and HashTable 
    * Hashtable is synchronized and hence has slower performance
    * Hashtable iterator is not fail-safe
    * Hashtable doens't allow null for key and value
	
	* HashMap are not synchronized and therefore has better performance
	* Hashmap iteratores is fail-safe
	* Hashmap allows null for both key and values
	
	* HashSet does not allow duplicate values
	* HashSet only takes key - it has add 
	
	
* Vectors versus ArrayList
	* Vector is synchronized. ArrayList is not
	* Iterators for both are fail-safe. Enumeration returned by vector are not
	* Data growth - Internally, both the ArrayList and Vector hold onto their 
	contents using an Array. When an element is inserted into an ArrayList or a Vector, 
	the object will need to expand its internal array if it runs out of room. A Vector 
	defaults to doubling the size of its array, while the ArrayList increases its array 
	size by 50 percent.  

* Difference between Iterators and Enumerations
	* Enumeration is old. Iterators are new.
	* Enumeration are read only. Iterators has remove() method.
	* Iterators allow removing element will iterating. Enumerations don't. Enumeration acts as 
	Read-only interface, because 
	it has the methods only to traverse and fetch the objects, where as by using Iterator we can 
	manipulate the objects like adding and removing the objects from collection e.g. Arraylist.
	* Also Iterator is more secure and safe as compared to Enumeration because it  does not allow other thread 
	to modify the collection object while some thread is iterating over it and throws

Benefit of linkedlist over array:
  * you don't need continuous space
  * you don't need to predefined space
  * efficiently utilization of space because you don't block any more space than currently required. 

Disadvantages of linked list
  * insertion takes order of N time
  * Difficult to maintain and recover 

HashTable
	* Usually uses array to store elements
	* usually made twice the initial size when full. Array size should be prime number and hence the new array size will be more than double. 
	* VERY IMPORTANT: table size should be prime number for open addressing 
	
Hashing Algorithm for Strings:
	* Approach 1:
	     Example: CATS
	     Approach 1: 3*27^0 + 1*27^0 + 20*27^1 + 19*27^0
			-- can't handle strings > 7
	     Approach 2 (Horner's Method): (((3*27+1)*27 + 20)*27 + 19)*27 
			-- can't handle strings > 7
	     Approach 3 
				((((3 % arraysize)*27 + 1) % arraysize)*27 + 20) % arraysize)*27 + 19
				
				--can be made faster using 32 base and then using bitwise operations for mod
				
	   
11 % 32 ==> 00001011 & 00011111 = 00001011
33 % 32 ==> 000100001 & 00011111 = 00000001
  	

Ways to handle Collisions in HashTable
	* Open Addressing: Collisions are resolved by looking for an open cell in the hash table. Generally load factor needs to be less than 1 (preferred is about 0.5 to 0.7)
		** Linear Probe
		** Quadratic Probe
		** Double Hashing
	* Separate Chaining: Each index is a linkedlist. Collisions are resolved by adding by simply adding the element to the linked list. Load factor can be 1 or more. Because of this, separate chaining is often preferred over open addressing. Table size doesn't need to be prime number. 
	
Advantages and Issues of HashTable

	* Issues
		** Based on arrays and hence need a good estimate of size beforehand
		** No easy way to scan the data in certain order
		** Work best when they are no more than 1/2 or 2/3 fill
	* Advantages
		** constant time lookup
		
Properties of HashFunction
	* Quick Computation
	* Random Keys
	* Non-Random Keys
	
	
Benefits/Issues of single linked list and double linked list -- think of applications ?
  
Properties of Red-Black Nodes:
* Root node is always black
* Red node will always have black children
* Black height/Depth of all paths is same

Height of red-black tree is in between: log_4(n) < h < 1 + log_2(n)
 
================== HEAP ===========================
* is a kind of tree for both insertion and deletion in O(logN) time
* Use for prioritizing items
* It's a binary tree with these characteristics:
	** Its complete
	** usually implemented as an array
	** Every node's key is larger than or equal to the keys of its children

2^0=1-1 = 0
2^1=2-1 = 1
2^2=4-1 = 3
2^3=8-1 = 7



Resources:
http://www.java-questions.com/collections_interview_questions.html
http://www.careercup.com/page?pid=hash-table-interview-questions


